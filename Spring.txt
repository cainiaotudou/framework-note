一，spring是什么
	spring是一个开源框架。
	spring为简化企业级应用开发而生，使用spring可以是简单的javabean实现以前只有EJB才能实现的功能
	spring是一个IOC（DI）和AOP容器框架
	
	具体描述Spring：
	--轻量级：spring是非侵入性的-基于spring开发的应用中的对象可以不依赖于spring的API
	--依赖注入（DI-dependencey injection ,IOC）	
	--面向切向变成（AOP）
	--容器：Spring是一个容器，因为他包含并且管理应用对象的生命周期
	--框架：spring实现了使用简单的组建配置组合成一个复杂应用，再spring中可以使用xml和java注解组合这些对象
	--一站式：在IOC和AOP的基础上可以整合各种企业应用的开源框架和优秀的第三方类库（实际上Spring自身也提供了展现层的SpringMVC和持久层的Spring JDBC）

二：IOC和DI
	IOC（Inversion of Control）：其思想是反转资源获取的方向，传统的资源查找方式要求组件向容器发起请求查找资源作为回应，容器适时的返回资源，而应用的IOC后，则是容器主动的吧资源
	推送它所管理的组件，组件所要做的就是选择一种合适的方式来接受资源，这种行为也被称为查找的被动形式
	
	DI（Dependencey Injection）：IOC的另一种表达方式，即组建以一些预先定义好的方式，（例如setter方法）接受来自如容器的注入，相对于IOC而言，这种表述更直接

三：配置bean

	1，配置形式：基于xml文件的方式/基于注解的方式
  <!--配置bean
	class：bean的全类名，通过反射的方式在IOC容器中创建Bean，所以要求Bean中必须有无参数构造器
	id：标识容器中bean，id，唯一
-->
    <bean id="helloWorld" class="spring.HelloWorld">
        <property name="name" value="Spring"></property>
    </bean>


	2，bean的配置方式：通过全类名（反射），通过工厂方法（静态工厂方法&实例工厂方法），FactoryBean


	3，IOC容器的BeanFactory&ApplicationContext概述
	BeanFactory面向spring本身，ApplicationContext面向框架开发人员
	ApplicationContext的主要实现类：
		ClassPathXmlApplicationContext：从类路径下加载配置文件
		FileSystemXmlApplicationContext：从文件系统中加载配置文件
	ConfigurableApplicationContext扩展于ApplicationContext，新增的两个主要方法：refresh（）和close（），让ApplicationContext具有启动，刷新和关闭上下文的功能
	ApplicationContext在初始化上下文时就实例化所有单例的Bean。
	WebApplicationContext是专门为web应用而准备的，它允许从相对于web根目录的路径中完成初始化工作

	 //（1）,创建spring的IOC容器对象，ApplicationContext代表IOC容器，ClassPathXmlApplicationContext是ApplicationContext接口的实现类，该实现从类路径读取配置文件
      	  ApplicationContext ctx = new ClassPathXmlApplicationContext("Config/applicationContext.xml");

	//（2）,从IOC容器中获取bean实例，利用id定位到IOC容器中的bean
	      HelloWorld helloWorld = (HelloWorld) ctx.getBean("helloWorld");
	  //利用类型返回IOC容器中的bean，但要求IOC容器中必须只能有一个该类型的bean
     	   HelloWorld helloWorld = (HelloWorld) ctx.getBean(HelloWorld.class);
	


	
	4，依赖注入的方式：
		属性注入：通过setter方法注入bena的属性值或依赖的对象，属性注入使用<property>元素，使用name属性指定Bean的属性名称，value属性或<value>子节点指定属性值（常用
			实体类中不能有有参构造器
		    <bean id="helloWorld" class="spring.HelloWorld">
      		  <property name="name" value="Spring"></property>
  		  </bean>

		构造器注入：（需要实体类里面有无参构造器）
		    <bean id="car" class="spring.Car">
    		    <constructor-arg value="baoma" index="0"></constructor-arg>
     		    <constructor-arg value="1001" type="int"></constructor-arg>
  		    </bean>
  		    <bean id="car1" class="spring.Car">
    		    <constructor-arg value="benci"></constructor-arg>
    		    <constructor-arg value="300000.0" type="double"></constructor-arg>
  		   </bean>


	注入属性值的细节：
		（1）属性值可以使用value子节点<value><value/>进行配置。 如果字面值包含特殊字符可以使用<[!CDATA[]]>包裹起来
		<constructor-arg index="0">
         		   <value><![CDATA[<baoma>]]></value>
      		  </constructor-arg>


	5，bean的引用
		（1）引用bean 通过ref来引用
		    <bean name="user" class="spring.User">
     		   <property name="name" value="tudou"></property>
        		   <property name="sex" value="nan"></property>
      		   <property name="car" ref="car"></property>
    		    </bean>
		（2）可以内部bean（这里用构造注入和属性注入都可以）
		 <bean name="user1" class="spring.User">
      		  <property name="name" value="tudou"></property>
      		  <property name="sex" value="nan"></property>
      		  <property name="car">
       		     <bean id="car3" class="spring.Car">
          		      <constructor-arg value="audi" index="0"></constructor-arg>
          		      <constructor-arg value="1002" type="int"></constructor-arg>
          		  </bean>
    		    </property>
		    </bean>

	6，可以使用专用的<null/>元素标签为Bean的字符串或其他对象类型的属性注入null值

	7，和mybatis和hibernate一样，spring支持级联属性

		（1）级联属性赋值--注意：属性需要先初始化后才可以为级联属性赋值，否则会有异常，和struts2不同
		    <bean name="user1" class="spring.User">
        		<property name="name" value="tudou"></property>
       		 <property name="sex" value="nan"></property>
       		 <property name="car">
      		      <bean id="car3" class="spring.Car">
       		         <constructor-arg value="audi" index="0"></constructor-arg>
        		        <constructor-arg value="1002" type="int"></constructor-arg>
       		     </bean>
   		     </property>
     		   <property name="car.price" value="1000.1"></property>
  		  </bean>
		
	8.在spring中可以通过一组内置的xml标签来配置一些集合属性 list set map
		（1）Spring中可以配置list类型的属性，需要指定<list>标签。这些标签可以通过<value>来指定一些属性，<ref>指定对其他bean的引用，通过<bean>指定内置bean定义
		    <bean id="car" class="Collection.Car">
        <constructor-arg index="0">
            <value><![CDATA[<baoma>]]></value>
        </constructor-arg>
        <constructor-arg value="1001" type="int"></constructor-arg>
    </bean>
    <bean id="car2" class="Collection.Car">
        <constructor-arg index="0">
            <value><![CDATA[<aodi>]]></value>
        </constructor-arg>
        <constructor-arg value="1002" type="int"></constructor-arg>
    </bean>
    <bean id="car1" class="Collection.Car">
        <constructor-arg index="0">
            <value><![CDATA[<benci>]]></value>
        </constructor-arg>
        <constructor-arg value="1003" type="int"></constructor-arg>
    </bean>

    <bean id="user2" class="Collection.User">
        <property name="name" value="langweixianer"></property>
        <property name="sex" value="nv"></property>
        <property name="cars">
            <list>
                <ref bean="car"></ref>
                <ref bean="car1"></ref>
                <ref bean="car2"></ref>
            </list>
        </property>
    </bean>
	
		（2）使用map节点以及entry子节点配置Map类型的成员变量
		    <bean id="user3" class="Collection.User">
        <property name="name" value="langweixianer"></property>
        <property name="sex" value="nv"></property>
        <property name="cars">
            <map>
                <entry key="AA" value-ref="car"></entry>
                <entry key="BB" value-ref="car1"></entry>
            </map>
        </property>
    </bean>	

		（3）使用<props>定义Properties，该标签使用多个<prop>作为子标签，每个<prop>标签必须定义key属性
		    <bean id="datesource" class="Collection.DateSource">
        <property name="properties">
            <props>
                <prop key="username">tudou</prop>
                <prop key="password">1234</prop>
                <prop key="url">jdbc:mysql://localhost</prop>
                <prop key="dricer">com.mysql.cj.jdbc.driver</prop>
            </props>
        </property>
    </bean>
		
		（4）配置单例的结合bean，以供多个bean进行引用，需要导入util命名空间
 <util:list id="cars">
        <ref bean="car"></ref>
        <ref bean="car1"></ref>
    </util:list>
引用bean：        <property name="cars" ref="cars"></property>


		（5）通过p命名空间为bean属性赋值，需要先导入p命名空间，相对于传统的方式更加简洁
    <util:list id="cars">
        <ref bean="car"></ref>
        <ref bean="car1"></ref>
    </util:list>

    <bean id="user3" class="Collection.User" p:name="tudou" p:sex="nan" p:cars-ref="cars"></bean>


	8.自动装配：SpringIOC可以自动装备Bean，需要做的仅仅是在<bean>的autowire属性里面只当自动装配的模式
		byName――――――》
    <bean id="car" class="AutoWire.Car" p:carname="hongqi" p:num="10005" p:price="9999.99"></bean>
    <bean id="adress" class="AutoWire.Adress" p:city="beijin" p:country="China"></bean>
    <bean id="user" class="AutoWire.User" p:sex="nan" p:name="tudou" autowire="byName"></bean>

		byType：――――》和上面的类似，通过实体类来自动匹配，如果<bean>中出现两个一样的实体类bean 就会报错 例如
		<bean id="car1" class="AutoWire.Car" p:carname="hongqi" p:num="10005" p:price="9999.99"></bean>
		<bean id="car2" class="AutoWire.Car" p:carname="hongqi" p:num="10005" p:price="9999.99"></bean>
	
	――――》一般情况下，在实际的项目中很少使用自动装备功能，因为和自动装备功能所带来的好处相比，明确清晰的配置文档更有说服力

	
	9，bean配置的继承，抽象bean
	 继承――――》
	<bean id="car" class="AutoWire.Car" p:carname="hongqi" p:num="10005" p:price="9999.99"></bean>
	<bean id="car1" parent="car"></bean>
	抽象Bena――――》
	 <bean id="car" class="AutoWire.Car" p:carname="hongqi" p:num="10005" p:price="9999.99" abstract="true"></bean>被设置为模板  只能被继承 不能被引用

	10，要求再配置User时候，必须有一个关联的car，就是User的bean依赖于Car这个bean
	<bean id="user2" class="AutoWire.User" p:name="haha" p:sex="nv" p:adress-ref="adress" depends-on="car"></bean>


	11，bean的作用域，通过scope属性来配置bean的作用域
	singleton：默认值，容器初始时创建bena实例，就会加载car实例，在整个容器的生命周期内只创建这一个bean，单例的。
	<bean id="car" class="AutoWire.Car" p:carname="hongqi" p:num="10005" p:price="9999.99" scope="singleton"></bean>

	prototype：原型的，容器初始化时候不创建bean的实例，而在每次请求时都创建一个新的bena实例，并返回
	<bean id="car" class="AutoWire.Car" p:carname="hongqi" p:num="10005" p:price="9999.99" scope="prototype"></bean>
	
	
	12，使用外部属性文件
   <context:property-placeholder location="db.properties"></context:property-placeholder>

    <bean id="datesource" class="AutoWire.DateSource">
        <property name="properties">
            <props>
                <prop key="username">${username}</prop>
                <prop key="password">${password}</prop>
                <prop key="url">${url}</prop>
                <prop key="driver">${driver}</prop>
            </props>
        </property>
    </bean>

	13，SpEL
	语法类似于：EL：SpEL使用#{。。}作为界定符，所有在大框号中的字符都将被认为是SpEL
	通过SpEL可以实现：（1）通过bean的id对bean进行引用 （2）调用方法以及引用对象中的属性 （3）计算表达式的值 （4）正则表达式的匹配 等等


・	14，IOC容器中bean的生命周期方法
	--springIOC容器可以管理bean的生命周期，spring允许在bean生命周期的特定点执行特定任务
	--SpringIOC容器对Bean的生命周期进行管理的过程：
		（1）通过构造器或工厂方法创建Bena实例
			Car.java
		（2）为Bean的属性设置值对其他的Bean的引用
			applictaionContext.xml
		（3）调用Bena的初始化方法
			applictaionContext.xml中bean里面的init-method 调用   Car.java中的init方法
		（4）Bean可以使用了
		（5）当容器关闭的时候，调用Bean的销毁方法
			applictaionContext.xml中bean里面的destroy-method 调用   Car.java中的destroy方法
	--在Bean的生命里设置init-method和destroy-method属性，为Bean指定初始化和销毁方法

――――――――java
public class Car {
    private String carname;
    private int num;
    private double price;
    public void init(){
        System.out.println("init open !");
    }
    public void destroy(){
        System.out.println("destroy open!");
    }}

――――――――main
 public static void main(String[] args){
        ApplicationContext ctx = new ClassPathXmlApplicationContext("Config/applicationContext6.xml");
        Car car = (Car) ctx.getBean("car");
        System.out.println(car);
        ((ClassPathXmlApplicationContext) ctx).close();}	
	
――――――――――xml	
<bean id="car" class="Beancycle.Car" init-method="init" destroy-method="destroy">
        <property name="carname" value="宝马"></property>
        <property name="num" value="10002"></property>
    </bean>

――――――――――配置后置处理器 BeanPostProcessor
    <!--实现BeanPostProcessor接口，并提供具体的方法
    before方法是 init之前被调用
    after方式是 init之后被调用
    返回值：是实际上返回给用户的那给bean，注意：可以用以上两个方法修改返回的bean，甚至返回另外一个bean
    -->
    <!--配置后置处理器 不需要配置id，IOC回制动识别是一个BeanPostProcessor-->
    <bean class="Beancycle.MyBeanPostProcessor"></bean>

――――――――――postprocessor后置处理器
public class MyBeanPostProcessor implements BeanPostProcessor {
    @Override
    public Object postProcessBeforeInitialization(Object bean, String beanname) throws BeansException {
        System.out.println("postProcessBeforeInitialization" + bean + ":" +beanname);
        return bean;}
    @Override
    public Object postProcessAfterInitialization(Object bean, String beanname) throws BeansException {
        System.out.println("postProcessAfterInitialization" + bean + ":" +beanname);
        Car car = new Car();
        car.setCarname("奔驰");
        return car;}}

	
	15.静态工厂方法
――――――――Java
public class StaticCarFactory {
    private static Map<String,Car> cars = new HashMap<String,Car>();

    static {
        cars.put("audi",new Car("audi",30000.0));
        cars.put("boama",new Car("baoma",50000.0));
    }
    //静态工厂方法
    public static Car getCar(String name){
        return cars.get(name);
    }}
――――――――xml
    <!--通过静态工厂方法来配置Bean，注意不是配置静态工厂方法实例，而是配置Bean实例
    factory-method：指向工厂方法的名字
    constructor-arg：如果工厂方法需要传入参数，就用这个来配置参数-->
    <bean id="car1" class="StaticCarFactory.StaticCarFactory" factory-method="getCar">
        <constructor-arg value="audi"></constructor-arg>
    </bean>

	16，实例工厂方法
――――――》java
public class InstanceCarFactory {
    private Map<String,Car> cars = null;

    public InstanceCarFactory(){
        cars = new HashMap<String,Car>();
        cars.put("audi",new Car("奥迪",70000.0));
        cars.put("baoma",new Car("宝马",80000.0));
    }

    public Car getCar(String carname){
        return cars.get(carname);
    }
}
――――――――》xml

    <bean id="carFactory" class="InstanceCarFactory.InstanceCarFactory"></bean>
    <bean id="car2" factory-bean="carFactory" factory-method="getCar">
        <constructor-arg value="audi"></constructor-arg>
    </bean>

	17.FactoryBean配置
――――――》java
public class carFactoryBean implements FactoryBean<Car> {
    private String brand;
    public void setBrand(String brand) {
        this.brand = brand;
    }
    @Override
    public Car getObject() throws Exception {
        return new Car(brand,520000);
    }
    @Override
    public Class<?> getObjectType() {
        return Car.class;
    }
    @Override
    public boolean isSingleton() {
        return true;
    }
}
――――――――――――》xml
   <!--通过FactoryBean来配置Bena的实例
    class：指向FactoryBean的全类名
    property：配置FactoryBean的属性
    但实际返回的实例却是FactoryBean的getObject（）方法返回的实例-->
    <bean id="car" class="CarFactoryBean.carFactoryBean">
        <property name="brand" value="baoma"></property>
    </bean>



四，配置bean基于注解的方式――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
	组件扫描：spring能够从classpath下自动扫描，侦测和实例化具有特定注解的组件
	特定组件包括：
	-@Component：基于注解，标识了一个受Spring管理的组件
	-@respository：标识持久层组件
	-@Service：标识服务层组件
	-@Controller：标识表现层组件
	对于扫描到的组件，Spring有默认的命名策略，使用非限定类名，第一个字母小写，也可以在注解中通过value属性值标识组件的名称
――――――――――――――java
（1）@注解
@Controller
public class UserController {
}
@Repository("userRepository")   //可以命名组件名称
public class UserRepositoryImp implements UserRepository {
}
@Service
public class UserService {
}
@Component
public class TestObject {
}
――――――――――――――xml     扫描注解文件的包 这里 annotation是主包  以上的几个类都在annotation的子包里面
    <!--指定IOC容器扫描的包
    1.排除，这个包里面的类不行-->
    <context:component-scan base-package="annotation" use-default-filters="false">
        <context:exclude-filter type="annotation" expression="org.springframework.stereotype.Service"></context:exclude-filter>
    </context:component-scan>
    
    <!--2.包含 只有这个类才可以  不过要声明use-default-filters="false"-->
    <context:component-scan base-package="annotation" use-default-filters="false">
        <context:include-filter type="annotation" expression="org.springframework.stereotype.Service"></context:include-filter>
    </context:component-scan>
    <!--3.排除，这个类不行-->
    <context:component-scan base-package="annotation" >
        <!--这里面的expression路径是类的路径-->
        <context:exclude-filter type="assignable" expression="annotation.service.UserService"></context:exclude-filter>
    </context:component-scan>
    <!--4.包含，只有这个类才可以 不过要声明use-default-filters="false"-->
    <context:component-scan base-package="annotation" use-default-filters="false">
        <!--这里面的expression路径是类的路径-->
        <context:exclude-filter type="assignable" expression="annotation.service.UserService"></context:exclude-filter>
    </context:component-scan>

――――――――――――――――――――――――――――――――――――――――――java 测试
    public static void main(String[] args){
        ApplicationContext ctx = new ClassPathXmlApplicationContext("Config/zhujie.xml");
        UserController userController = (UserController) ctx.getBean("userController");
        System.out.println(userController);
        UserRepository userRepository = (UserRepository) ctx.getBean("userRepository");
        System.out.println(userRepository);
        UserService userService = (UserService) ctx.getBean("userService");
        System.out.println(userService);
        TestObject testObject = (TestObject) ctx.getBean("testObject");
        System.out.println(testObject);
    }


  	2。使用@Autowired自动装备Bean
――――――main开始
  public static void main(String[] args){
        ApplicationContext ctx = new ClassPathXmlApplicationContext("Config/zhujie.xml");
        UserController userController = (UserController) ctx.getBean("userController");
        userController.execute();
―――――――第一
@Controller
public class UserController {
    @Autowired//就是这个
    private UserService userService;
    public void execute(){
        System.out.println("UserController execute..");
        userService.add();
    }
}
――――――――第二
@Service
public class UserService {
    @Autowired
    private UserRepository userRepository;
    public void add(){
        System.out.println("UserService add..");
        userRepository.save();
    }
}
――――――――――第三
@Repository("userRepository")
public class UserRepositoryImp implements UserRepository {

    @Override
    public void save() {
        System.out.println("UserRepositoryImp save");
    }
}




五。Spring4.x 新特性：泛型依赖注入――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
_____________________________________――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――



六：Spring AOP――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――_____
_______________――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
************Idea的Spring项目中需要导入aspectjweaver-1.9.1.jar

在spring中启用AspectJ注解支持
	-要在Spring应用中使用AspectJ注解，必须在classpath下包含AspectJ类库，aopalliance.jar
	-讲aopSchema添加到《beans》元素中
	-要在SpringIOC容器中启用AspectJ注解支持，只要在Bean配置文件中定义一个空的XML元素<aop:aspectj-autoproxy>
	-在SpringIOC容器侦测到Bean配置文件中
	<aop:aspectj-autoproxy>元素时，会自动为与AspectJ切面匹配的Bean创建代理


――――――――――――――――――――――――――――――――――――――――――――――――――――――――
―――――――――――――――――――――――――――――――――――――――――――――――――――――――――基于注解的方式配置切面文件：
	1，前置通知
（1）配置文件――――――――--――――    xml
<!--配置自动扫描的包-->
    <context:component-scan base-package="calculator"></context:component-scan>
    <!--是AspectJ注解起作用:自动为匹配的类生成代理对象-->
    <aop:aspectj-autoproxy></aop:aspectj-autoproxy>



（2）――――――――――――――――――――声明AOP切面  并且放入IOC容器中（也就是注解）
//把横切关注点的代码抽象到切面的类当中
//i:切面首先是一个IOC中的bean'，要加入@Commponent
//ii：切面还需要加入@Aspect注解
@Aspect
@Component
public class LoggingAspect {
    @Before("execution(public int calculator.MyCalculator.*(int,int))")   //声明一个方法 在方法前面加@Before  execution(* calculator.MyCalculator.*(..))
    public void beforeMethod(JoinPoint joinPoint){
	//可以在通知方法中声明一个类型为JoinPoint的参数，然后就能访问链接细节，如方法名和参数值
               String methodName = joinPoint.getSignature().getName();
        List<Object> args = Arrays.asList(joinPoint.getArgs());
        System.out.println("The method " + methodName + "begin with" + args );
    }
}


――――――――――――Internet接口
public interface MyCalculator {
    public int add(int i,int j);
    public int sub(int i,int j);
    public int mul(int i,int j);
    public int div(int i,int j);
}

――――――――――――――――――――――――――引用接口并且放入IOC容器当中（也就是注解）
@Component
public class Calculator implements MyCalculator{
    @Override
    public int add(int i, int j) {
        int result = i + j;
        return result;
    }
    @Override
    public int sub(int i, int j) {
        int result = i - j;
        return result;
    }
    @Override
    public int mul(int i, int j) {
        int result = i * j;
        return result;
    }
    @Override
    public int div(int i, int j) {
        int result = i / j;
        return result;
    }
}

――――――――――――――――――――――――main.java
public class Main {
    public static void main(String[] args){
        ApplicationContext ctx = new ClassPathXmlApplicationContext("config/spring.xml");
        MyCalculator calculator = (MyCalculator) ctx.getBean(MyCalculator.class);         //这里的getBena写的是接口类，注意
        int result = calculator.add(2,4);
        System.out.println(result);
    }
}


	2.后置通知（在目标方法执行后（无论是否发生异常），执行通知）
   @After("execution(* calculator.MyCalculator.*(..))")
    public void afterMethod(JoinPoint joinPoint)
    {
        String methodName = joinPoint.getSignature().getName();
        System.out.println("The method " + methodName + " end !");
    }

	3.返回通知（在方法返回结果之后执行）：是可以访问到返回值的
    @AfterReturning(value="execution(* calculator.MyCalculator.*(..))",returning = "result")
    public void afterMethod(JoinPoint joinPoint,Object result)
    {
        String methodName = joinPoint.getSignature().getName();
        System.out.println("The method " + methodName + " end with " + result);
    }

	4.异常通知（在方法抛出异常之后执行）
    @AfterThrowing(value="execution(* calculator.MyCalculator.*(..))",throwing = "ex")
    public void afterMethod(JoinPoint joinPoint,Exception ex)
    {
        String methodName = joinPoint.getSignature().getName();
        System.out.println("The method " + methodName + " occur Exception : " + ex);
    }

	5.环绕通知（）
	    @Around("execution(* calculator.MyCalculator.*(..))")
    public Object aroundMethod(ProceedingJoinPoint proceedingJoinPoint){
        Object result = null;
        String methodName = proceedingJoinPoint.getSignature().getName();

        try {
            //前置通知
            System.out.println("The method " + methodName + " begin with " + Arrays.asList(proceedingJoinPoint.getArgs()));
            //执行目标方法
            result = proceedingJoinPoint.proceed();
            //后置通知
            System.out.println("The method " + methodName + " end with " + result);
        } catch (Throwable e) {
            //异常通知
            System.out.println("The method " + methodName + " occur Exception : " + e);
            throw new RuntimeException();
        }
        //后置通知
        System.out.println("The method " + methodName + " end with ");
        return result;
    }

	
	6.切面优先级
	用@Order（）来决定切面的优先级
@Order(1)
@Aspect
@Component
public class CheckAspect {//切面1

@Order(2)
@Aspect
@Component
public class LoggingAspect {	//切面2


	7.定义一个方法，用于声明切入点的表达式，一般的，改方法中再不需要填入其他的代码
	使用@Pointcut声明切入点，后面用方法来引用切入点
	
	    @Pointcut("execution(* calculator.MyCalculator.*(..))")//这里声明切入点 并创建方法
  	 public void mmm(){}

	    @Before("mmm()")//写这个方法就直接调用切入点
    public void beforeMethod(JoinPoint joinPoint)
    {
        String methodName = joinPoint.getSignature().getName();
        List<Object> args = Arrays.asList(joinPoint.getArgs());
        System.out.println("The method " + methodName + " begin with " + args );
    }
	

――――――――――――――――――――――――――――――――――――――――――――――――――――――――
―――――――――――――――――――――――――――――――――――――――――――――――――――――――――基于配置文件的方式配置切面文件：


1，配置文件――――――――――――――――――――――――――xml
	//切面配置
    <bean id="checkAspect" class="calculatorBean.CheckAspect"></bean>
    <bean id="loggingAspect" class="calculatorBean.LoggingAspect"></bean>
	//实体类配置
    <bean id="calculator" class="calculatorBean.Calculator"></bean>
    <!--配置AOP-->
    <aop:config>
        <!--切点配置-->
        <aop:pointcut id="pointcut" expression="execution(* calculatorBean.MyCalculator.*(..))"></aop:pointcut>
        <!--配置切面和通知-->
        <aop:aspect ref="checkAspect" order="1">
            <aop:before method="beforeMethod" pointcut-ref="pointcut"></aop:before>
        </aop:aspect>
        <aop:aspect ref="loggingAspect" order="2">
            <aop:before method="beforeMethod" pointcut-ref="pointcut"></aop:before>
            <aop:after method="afterMethod" pointcut-ref="pointcut"></aop:after>
            <aop:after-throwing method="afterThrowing" pointcut-ref="pointcut" throwing="ex"></aop:after-throwing>
            <aop:after-returning method="afterReturning" pointcut-ref="pointcut" returning="result"></aop:after-returning>
        </aop:aspect>
        <!--<aop:aspect ref="loggingAspect" order="2">-->
            <!--<aop:around method="aroundMethod" pointcut-ref="pointcut"></aop:around>-->
        <!--</aop:aspect>-->
    </aop:config>

――――――――――――――――――――――――――――java
public class LoggingAspect {

//    public void beforeMethod(JoinPoint joinPoint)
//    {
//        String methodName = joinPoint.getSignature().getName();
//        List<Object> args = Arrays.asList(joinPoint.getArgs());
//        System.out.println("The method " + methodName + " begin with " + args );
//    }
//    public void afterMethod(JoinPoint joinPoint)
//    {
//        String methodName = joinPoint.getSignature().getName();
//        System.out.println("The method " + methodName + " end !");
//    }
//    public void afterMethod(JoinPoint joinPoint,Object result)
//    {
//        String methodName = joinPoint.getSignature().getName();
//        System.out.println("The method " + methodName + " end with " + result);
//    }
//    public void afterMethod(JoinPoint joinPoint,Exception ex)
//    {
//        String methodName = joinPoint.getSignature().getName();
//        System.out.println("The method " + methodName + " occur Exception : " + ex);
//    }
    public Object aroundMethod(ProceedingJoinPoint proceedingJoinPoint){
        Object result = null;
        String methodName = proceedingJoinPoint.getSignature().getName();

        try {
            //前置通知
            System.out.println("The method " + methodName + " begin with " + Arrays.asList(proceedingJoinPoint.getArgs()));
            //执行目标方法
            result = proceedingJoinPoint.proceed();
            //后置通知
            System.out.println("The method " + methodName + " end with " + result);
        } catch (Throwable e) {
            //异常通知
            System.out.println("The method " + methodName + " occur Exception : " + e);
            throw new RuntimeException();
        }
        //后置通知
        System.out.println("The method " + methodName + " end with ");
        return result;
    }
}




七：Spring和Hibernate的整合
	1：操作数据库：
――――――――――――――――配置xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:p="http://www.springframework.org/schema/p" xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd">

    <!--导入资源文件-->
    <context:property-placeholder location="classpath:db.properties"></context:property-placeholder>

    <!--配置c3p0数据源-->
    <bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource">
        <property name="user" value="${jdbc.user}"></property>
        <property name="password" value="${jdbc.password}"></property>
        <property name="jdbcUrl" value="${jdbc.jdbcUrl}"></property>
        <property name="driverClass" value="${jdbc.driverClass}"></property>
        <property name="initialPoolSize" value="${jdbc.initialPoolSize}"></property>
        <property name="maxPoolSize" value="${jdbc.maxPoolSize}"></property>
    </bean>

    <!--配置SPring的JdbcTemplate-->
    <bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate">
        <property name="dataSource" ref="dataSource"></property>
    </bean>
</beans>
――――――――――――――――――――――――――――java

public class JDBCtest {

    private ApplicationContext ctx = null;
    private JdbcTemplate jdbcTemplate;

    {
        ctx = new ClassPathXmlApplicationContext("applicationContext.xml");
        jdbcTemplate = (JdbcTemplate) ctx.getBean("jdbcTemplate");
    }

    @Test//获取单个列的值，或者统计查询 使用
    public void testQuery(){
        String sql = "select count(*) from student";
        int count = jdbcTemplate.queryForObject(sql,Integer.class);
        System.out.println(count);
    }
    //查实体类的集合
    @Test
    public void testQueryForList(){
        String sql = "select stuName stu_nAme,sex,grade from student where id > ?";
        RowMapper<Student> mapper = new BeanPropertyRowMapper<>(Student.class);
        List<Student> list =  jdbcTemplate.query(sql,mapper,10);
        System.out.println(list);
    }

    @Test //从数据获取一条记录，实际得到对应的一个对象
    //1.其中的RowMapper指定如何去映射结果集的行，常用的实现类是BeanPropertyRowMapper
    //2，使用SQL中列的别名完成列名和类的属性名的映射，类如stuName stu_name  别名为实体类中的变量
    //3，不支持级联
    public void testQueryForObejct(){
        String sql = "select stuName stu_name,sex,grade from student where id=?";
        RowMapper<Student> rowMapper = new BeanPropertyRowMapper<>(Student.class);
        Student student = jdbcTemplate.queryForObject(sql,rowMapper,1);
        System.out.println(student);

    }

    @Test //批量更新：修改一条记录需要一个Object的数组，多条就需要一个List数组
    public void testBatchUpdate(){
        String sql = "insert into books(bookname,price,author,bookType) values(?,?,?,?)";
        List<Object[]> batchArgs = new ArrayList<>();
        batchArgs.add(new Object[]{"aiai1",20,"豆豆",1});
        batchArgs.add(new Object[]{"aiai1",20,"豆豆",1});
        jdbcTemplate.batchUpdate(sql,batchArgs);
    }
    @Test //更新
    public void testUpdate(){
        String sql = "update books set bookName=? where id=?";
        jdbcTemplate.update(sql,"相爱",1);
    }

    @Test //获取数据库数据源
    public void testDataSource(){
        DataSource dataSource = (DataSource) ctx.getBean(DataSource.class);
        try {
            System.out.println(dataSource.getConnection());
        } catch (SQLException e) {
            e.printStackTrace();
        }

    }
		
		
	2，在JDBC模板中使用具名参数
――――――――――――――――――――――――――――――――――――――――――xml
    <!--配置具名参数：具有名字的参数-->
    <bean id="namedParameterJdbcTemplate" class="org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate">
        <constructor-arg ref="dataSource"></constructor-arg>
    </bean>
――――――――――――――――――――――――――――――――――――――――java
 private NamedParameterJdbcTemplate namedParameterJdbcTemplate = null；
{
 namedParameterJdbcTemplate = (NamedParameterJdbcTemplate) ctx.getBean("namedParameterJdbcTemplate");
}

 @Test//可以为参数起名字
    //好处：如果有多个参数，不需要？来对应位置，直接对应参数名字，便于维护   坏处：较为麻烦
    public void testNamedParameterJdbcTemplate2(){//方法一
        //具名使Sql语句中的参数名和类的属性一致
        String sql = "insert into student(stuName,sex,grade) values(:stu_Name,:sex,:grade)";
        Student student = new Student();
        student.setStu_Name("沈阳");
        student.setGrade("高一");
        student.setSex("nv");
        //就可以使用传入对象的方法 获取参数源
        SqlParameterSource sqlParameterSource = new BeanPropertySqlParameterSource(student);
        //再使用update另外一个方法实现更新
        namedParameterJdbcTemplate.update(sql,sqlParameterSource);
    }
    public void testNamedParameterJdbcTemplate(){//方法一
        String sql = "insert into student(stuName,sex,grade) values(:sName,:sex,:grade)";
        Map<String,Object> map = new HashMap<>();
        map.put("sName","辽大");
        map.put("sex","nv");
        map.put("grade","大学");
        namedParameterJdbcTemplate.update(sql,map);
    }



八：事务（基于注解方式）――――――――――――――――――――――――――――――――――――――――――――――――――――――
――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
例子参考Idea里面的SpringHbm项目


――――――――――――――――》xml
    <!--配置事务管理器-->
    <bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
        <property name="dataSource" ref="dataSource"></property>
    </bean>

    <!--启动事务注解-->
    <tx:annotation-driven transaction-manager="transactionManager" proxy-target-class="true"></tx:annotation-driven>
							*****注意：proxy-target-class="true"
――――――――――――――――》java
    @Transactional
    @Override
    public void purchase(String userName, String bookName) {
        Double price = bookShop.findBookPriceBybn(bookName);
        bookShop.updateBookStock(bookName);
        bookShop.updateUserAccount(userName,price);
    }


一：事务的传播属性：
	当事务方法被另一个事务方法调用时候，必须指定事务应该如何传播，例如：方法可能继续在现有的事务中运行，也可能开启一个新事物，并在自己的事务中运行
	事务的传播行为可以有传播属性指定，spring定义了7种类传播行为


事务1	
@Service
public class BookShopService implements BookShopSeriviceDao{
    @Autowired
    private BookShop bookShop;

    @Transactional(propagation = Propagation.REQUIRES_NEW)
    @Override
    public void purchase(String userName, String bookName) {
        Double price = bookShop.findBookPriceBybn(bookName);
        bookShop.updateBookStock(bookName);
        bookShop.updateUserAccount(userName,price);
    }
}

事务二
@Service
public class BuyBooksImp implements BuyManyBook {
    @Autowired
    private BookShopService bookShopService;

    @Transactional
    @Override
    public void buys(String userName, List<String> lists) {
        for(String list : lists){
            bookShopService.purchase(userName,list);
        }
    }
}

	事务二包裹事务一：@Transactional(propagation = Propagation.REQUIRES_NEW)    --》  事务一就会开启自己的事务，事务二就会被挂起，事务一会执行两次，
									成功就通过，两次执行不会相互干扰
			@Transactional(propagation = Propagation.REQUIRED) ---》默认值：只使用最外层的事务，内部任何一个环节一旦出错，整个事务回滚



二：事务的隔离级别
	使用isolation指定事务的隔离级别，
	最常用的：isolation = Isolation.READ_COMMITTED 读与提交
	noRollbackFor = {UserAccountException.class} 对指定的不进行回滚
	readOnly = true 指定事务是否为只读，可以帮助数据库引擎优化
	timeout=1  指定强制回滚事务之前可以占用多少时间
	――――――――》通常情况下采用默认值即可




九：事务（基于xml文件方式）――――――――――――――――――――――――――――――――――――――――――――――――――――――
――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
1；书店
public class BookShop implements BookShopDao {

    private JdbcTemplate jdbcTemplate;

    public void setJdbcTemplate(JdbcTemplate jdbcTemplate) {
        this.jdbcTemplate = jdbcTemplate;
    }

    public Double findBookPriceBybn(String bookName) {
       String sql = "select price from book1 where bookName=?";
       return jdbcTemplate.queryForObject(sql,Double.class,bookName);
    }

    @Override
    public void updateBookStock(String bookName) {
        //检查库存是否足够
        String sql1 = "select num from book_Stock where bookName = ?";
        int num = jdbcTemplate.queryForObject(sql1,Integer.class,bookName);
        if(num == 0){
            throw new BookStockException("库存不足");
        }
        String sql = "update book_Stock set num = num - 1 where bookName=?";
        jdbcTemplate.update(sql,bookName);

    }

    @Override
    public void updateUserAccount(String userName, double price) {
        String sql1 = "select money from account where userName = ?";
        double money = jdbcTemplate.queryForObject(sql1,Double.class,userName);
        //检查余额是否不足
        System.out.println(money);
        if((money - price) < 0 ){
            throw new UserAccountException("余额不足");
        }
        String sql = "update account set money = money - ? where userName = ?";
        jdbcTemplate.update(sql,price,userName);
    }
}

2：购买一本书操作
public class BookShopService implements BookShopSeriviceDao {

    private BookShop bookShop;

    public void setBookShop(BookShop bookShop) {
        this.bookShop = bookShop;
    }

    public void purchase(String userName, String bookName) {
        Double price = bookShop.findBookPriceBybn(bookName);
        bookShop.updateBookStock(bookName);
        bookShop.updateUserAccount(userName,price);
    }
}

3：购买多本书操作
public class BuyBooksImp implements BuyManyBook {
    private BookShopService bookShopService;

    public void setBookShopService(BookShopService bookShopService) {
        this.bookShopService = bookShopService;
    }

    public void buys(String userName, List<String> lists) {
        for(String list : lists){
            bookShopService.purchase(userName,list);
        }
    }
}

――――――――――
4-xml配置
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:p="http://www.springframework.org/schema/p" xmlns:context="http://www.springframework.org/schema/context"
       xmlns:tx="http://www.springframework.org/schema/tx"

       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/cache http://www.springframework.org/schema/cache/spring-cache.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd">
    <context:component-scan base-package="BookShop"></context:component-scan>

    <!--导入资源文件-->
    <context:property-placeholder location="classpath:db.properties"></context:property-placeholder>

    <!--配置c3p0数据源-->
    <bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource">
        <property name="user" value="${jdbc.user}"></property>
        <property name="password" value="${jdbc.password}"></property>
        <property name="jdbcUrl" value="${jdbc.jdbcUrl}"></property>
        <property name="driverClass" value="${jdbc.driverClass}"></property>
        <property name="initialPoolSize" value="${jdbc.initialPoolSize}"></property>
        <property name="maxPoolSize" value="${jdbc.maxPoolSize}"></property>
    </bean>

    <!--配置SPring的JdbcTemplate-->
    <bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate">
        <property name="dataSource" ref="dataSource"></property>
    </bean>

    <bean id="bookShop" class="BookShopxml.BookShop.BookShop">
        <property name="jdbcTemplate" ref="jdbcTemplate"></property>
    </bean>

    <bean id="bookShopService" class="BookShopxml.BookShop.BookShopService">
        <property name="bookShop" ref="bookShop"></property>
    </bean>

    <bean id="buyBooksImp" class="BookShopxml.BookShop.BuyBooksImp">
        <property name="bookShopService" ref="bookShopService"></property>
    </bean>

    <!--配置事务管理器-->
    <bean id="dataSourceTransactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
        <property name="dataSource" ref="dataSource"></property>
    </bean>

    <!--配置事务属性-->
    <tx:advice id="txAdvice" transaction-manager="dataSourceTransactionManager">
        <tx:attributes>
            <tx:method name="*"/>
        </tx:attributes>
    </tx:advice>

    <!--配置事务切入点，以及把事务切入点和事务属性关联起来-->
    <aop:config  proxy-target-class="true">   *********************************************************
				     **********************************************************一定要加这句话proxy-target-class="true" 草!!!!!!!
				    **********************************************************
        <aop:pointcut id="txPointCut" expression="execution(* BookShopxml.BookShop.BookShopSeriviceDao.*(..))"></aop:pointcut>
        <aop:advisor advice-ref="txAdvice" pointcut-ref="txPointCut"></aop:advisor>
    </aop:config>
</beans>

5.测试
public class Main {
    private ApplicationContext ctx = null;
    private BookShop bookShop = null;
    private BookShopService bookShopService = null;
    private BuyBooksImp buyBooksImp;
    {
        ctx = new ClassPathXmlApplicationContext("applicationContext1.xml");
        bookShop = (BookShop) ctx.getBean("bookShop");
        bookShopService = (BookShopService) ctx.getBean("bookShopService");
        buyBooksImp = (BuyBooksImp) ctx.getBean("buyBooksImp");
    }

    @Test
    public void test5(){
        buyBooksImp.buys("张三", Arrays.asList("可以不可以","十万个为啥"));
    }
    @Test
    public void test4() {
        bookShopService.purchase("张三","十万个为啥");
    }

    @Test
    public void test3() {
        bookShop.updateUserAccount("张三", 30);
    }

    @Test
    public void test2() {
        bookShop.updateBookStock("十万个为啥");
    }

    @Test
    public void test1() {
        System.out.println(bookShop.findBookPriceBybn("十万个为啥"));
    }
}




九：Spring整合Hibernate――――――――――――――――――――――――――――――――――――――――――――――――――――――
――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
1，整合什么
	（1）有IOC容器来管理Hibernate的SessionFactory
	（2）让Hibernate使用上Spring的声明式事务
	
2，整合步骤
	（1）加入Hibernate
	（2）加入Spring
	（3）整合

――――――――――――――――hibernate的配置文件
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE hibernate-configuration PUBLIC
        "-//Hibernate/Hibernate Configuration DTD 3.0//EN"
        "http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd">

<hibernate-configuration>
    <session-factory>
<!--配置hibernate的基本属性-->
        <!--1，数据源需配置到IOC容器中，所以此处不需要再配置数据源-->
        <!--2，关联 .hbm.xml 也再IOC容器中配置SessionFactory实例时再配置-->
        <!--3，配置hibernate的基本属性：方言。SQL显示格式化，生成数据表策略以及二级缓存等等-->
        <!--这个配置文件可要可不要，但建议留着，许多配置在这里面配置起来更方便-->
        
        <!-- show_sql: 操作数据库时,会 向控制台打印sql语句 -->
        <property name="show_sql">true</property>

        <!-- format_sql: 打印sql语句前,会将sql语句先格式化  -->
        <property name="format_sql">true</property>
        
        <property name="hbm2ddl.auto">update</property>

        <!-- 数据库方言配置 
         org.hibernate.dialect.MySQLDialect (选择最短的)
         -->
        <property name="hibernate.dialect">org.hibernate.dialect.MySQLDialect</property>

        <!-- hibernate.connection.autocommit: 事务自动提交  -->
        <property name="hibernate.connection.autocommit">true</property>

        <!-- 将Session与线程绑定=> 只有配置了该配置,才能使用getCurrentSession -->
        <property name="hibernate.current_session_context_class">thread</property>
    </session-factory>
</hibernate-configuration>

________――――――――――――――――――――――――――――――Spring的配置文件 以及整合SessionFactory
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context" xmlns:tx="http://www.springframework.org/schema/tx"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/cache http://www.springframework.org/schema/cache/spring-cache.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd">

    <!--配置数据源-->
    <!--导入数据源文件-->
    <context:property-placeholder location="classpath:dp.properties"></context:property-placeholder>
    <!--配置c3p0数据源-->
    <bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource">
        <property name="user" value="${jdbc.user}"></property>
        <property name="password" value="${jdbc.password}"></property>
        <property name="jdbcUrl" value="${jdbc.jdbcUrl}"></property>
        <property name="driverClass" value="${jdbc.driverClass}"></property>
        <property name="initialPoolSize" value="${jdbc.initialPoolSize}"></property>
        <property name="maxPoolSize" value="${jdbc.maxPoolSize}"></property>
    </bean>

    <!--配置Hibernate的SessionFactory实例-->
    <!--通过SPring提供的LocalSessionFactoryBean-->
    <bean id="sessionFactory" class="org.springframework.orm.hibernate4.LocalSessionFactoryBean">
        <!--配置数据源-->
        <property name="dataSource" ref="dataSource"></property>
        <!--配饰hibernate配置文件的位置以及名称-->
        <property name="configLocation" value="classpath:hibernate.cfg.xml"></property>
        <!--配置hibernate映射文件的位置以及名称,可以使用通配符-->
        <property name="mappingLocations" value="classpath:Hibernate_Entity/*.hbm.xml"></property>
    </bean>

    <!--配置spring的声明式事务-->
    <!--配置事务管理器-->
    <bean id="transactionManager" class="org.springframework.orm.hibernate4.HibernateTransactionManager">
        <property name="sessionFactory" ref="sessionFactory"></property>
    </bean>

    <!--配置事务属性-->
    <tx:advice id="txAdvice" transaction-manager="transactionManager">
        <tx:attributes>
            <tx:method name="get*" read-only="true"/>
            <tx:method name="*"></tx:method>
        </tx:attributes>
    </tx:advice>
    
    <!--配置事务切点和事务属性联系起来-->
    <aop:config>
        <aop:pointcut id="txPointCut" expression="execution(* Hibernate_Entity.*.*(..))"></aop:pointcut>
        <aop:advisor advice-ref="txAdvice" pointcut-ref="txPointCut"></aop:advisor>
    </aop:config>
</beans>



十：Spring整合Struts2――――――――――――――――――――――――――――――――――――――――――――――――――――――
――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
1：Spring如何在web应用中使用
	额外加入 spring-web  spring-webmvc 包
2：spring的配置文件，没有什么不同
3：如何创建IOC容器
（1）非web中在main中直接创建
（2）应该在web'应用被服务器加载时创建IOC容器	
	【监听】在ServiceContextListener#contextInitialized（ServletContextEvent sce）方法中创建IOC容器
（3）在web应用的其他组件中如何来访问IOC容器呢
 	在【监听】在ServiceContextListener#contextInitialized（ServletContextEvent sce）方法中创建IOC容器后，可以把其放在ServletCOntext（即application域）中的一个属性里面

―――――
――――
――――
――――――――――――Servlet
public class Servlet extends HttpServlet {
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {

    }

    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        //从appliaction域对象中得到IOc容器的引用
        ServletContext servletContext = getServletContext();
        ApplicationContext ctx = (ApplicationContext) servletContext.getAttribute("ApplicationContext");

        //从IOc容器中得到需要的bean
        User user = (User) ctx.getBean("user");
        user.hello();

    }
}
――――――――――――――listener.java
    public void contextInitialized(ServletContextEvent sce) {
        //获取Spring配置文件的名称
        ServletContext servletContext = sce.getServletContext();
        String config = servletContext.getInitParameter("contextConfigLocation");

        //创建IOC容器
        ApplicationContext ctx = new ClassPathXmlApplicationContext("applicationContext.xml");
        //把Ioc容器方法ServletContext的一个属性当中
        servletContext.setAttribute("ApplicationContext",ctx);
    }

_________――――――――――application.xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/cache http://www.springframework.org/schema/cache/spring-cache.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd">

    <bean id="user" class="lisener.User">
        <property name="userName" value="土豆"></property>
    </bean>

</beans>

――――――――――――――――――web.xml
<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"
         version="4.0">
    <filter>
        <filter-name>struts2</filter-name>
        <filter-class>org.apache.struts2.dispatcher.filter.StrutsPrepareAndExecuteFilter</filter-class>
    </filter>
    <filter-mapping>
        <filter-name>struts2</filter-name>
        <url-pattern>/*</url-pattern>
    </filter-mapping>

    <!--配置spring配置文件的名称和位置-->
    <context-param>
        <param-name>contextConfigLocation</param-name>
        <param-value>classpath:applicationContext.xml</param-value>
    </context-param>

    <!--启动IOC容器的ServletContextListener-->
    <listener>
        <listener-class>lisener.SpringListener</listener-class>
    </listener>
</web-app>

――――――――――――――User。java
public class User {
    private String userName;
    public void setUserName(String userName){
        this.userName=userName;
    }
    public void hello(){
        System.out.println("userName is" + userName);
    }
}
――――――――――――――――――――――――――――――――――Test.jsp
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
</head>
<body>
    <a href="Servlet">aaa</a>
</body>
</html>


十一：如何整合Spring和struts2
（1）整合目标？使IOC容器来管理Struts2的Action
（2）如何整合
  	1，正常加入struts2
	2，在spring的IOC容器中配置struts2的Action	
	注意：在IOC容器中配置struts2的Action时候，需要配置scope属性，非单例模式prototype
	3，配置Struts2的xml

――――――――――――――――――――――――applicationContext。xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean id="service" class="SpringtoAction.Service"></bean>


    <bean id="serviceAction" class="SpringtoAction.ServiceAction" scope="prototype">
        <property name="service" ref="service"></property>
    </bean>
</beans>
――――――――――――――――――――――――――java
public class Service {
    public void hello(){
        System.out.println("service begin！");
    }
}

public class ServiceAction {
    private Service service = null;
    public void setService(Service service){
        this.service=service;
    }
    public String execute(){
        System.out.println("Action begin");
        service.hello();
        return "success";
    }

}
――――――――――――――――――――――――――――――web.xml
<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"
         version="4.0">

    <filter>
        <filter-name>action2</filter-name>
        <filter-class>org.apache.struts2.dispatcher.filter.StrutsPrepareAndExecuteFilter</filter-class>
    </filter>

    <filter-mapping>
        <filter-name>action2</filter-name>
        <url-pattern>/*</url-pattern>
    </filter-mapping>

    <!--配置spring配置文件的名称和位置-->
    <context-param>
        <param-name>contextConfigLocation</param-name>
        <param-value>classpath:applicationContext.xml</param-value>
    </context-param>

</web-app>
――――――――――――――――――――――――――――――――――――struts2.xml
<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE struts PUBLIC
        "-//Apache Software Foundation//DTD Struts Configuration 2.5//EN"
        "http://struts.apache.org/dtds/struts-2.5.dtd">

<struts>
    <constant name="struts.enable.DynamicMethodInvocation" value="false"></constant>
    <constant name="struts.devMode" value="true"></constant>
    
    <package name="default" namespace="/" extends="struts-default">
        <action name="serviceAction" class="serviceAction">
            <result>/success.jsp</result>
        </action>
    </package>
</struts>